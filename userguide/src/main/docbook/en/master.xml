<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V4.2//EN"
"docbookV4.2/docbookx.dtd" [
<!ENTITY ch01-Introduction SYSTEM "modules/ch01-Introduction.xml">
<!ENTITY ch02-Installation SYSTEM "modules/ch02-Installation.xml">
<!ENTITY ch03-ErraiBus SYSTEM "modules/ch03-errai-bus.xml">
<!ENTITY appendix-A-Quickstart SYSTEM "modules/appendix-A-Quickstart.xml">
]>
<book lang="en">
  <bookinfo>
    <title>Errai User Guide</title>
  </bookinfo>

  <toc></toc>

     <!---
        =====================================================
        INTRODUCTION
        =====================================================
    -->

  <chapter id="introduction">
    <title>Introduction</title>

    <section>
      <title>What is it</title>

      <para>Errai is a GWT-based framework for building rich web applications
      using next-generation web technologies. Built on-top of ErraiBus, the
      framework provides a unified federation and RPC infrastructure with
      true, uniform, asynchronous messaging across the client and
      server.</para>
    </section>

    <section>
      <title>License and EULA</title>

      <para>Errai is distributed under the terms of the the Apache License,
      Version 2.0. See<ulink url="http://www.apache.org/licenses/LICENSE-2.0">
      the full Apache license text</ulink>.</para>
    </section>

    <section>
      <title>Downloads</title>

      <para>The distribution packages can be downloaded from jboss.org

      <ulink url="http://jboss.org/errai/Downloads.html">http://jboss.org/errai/Downloads.html</ulink>
        </para>
    </section>

    <section>
      <title>Sources</title>

      <para>The source code for this component can be found in the Errai SVN
      repository:

      <ulink
      url="http://anonsvn.jboss.org/repos/errai/trunk/">https://anonsvn.jboss.org/repos/errai/trunk/</ulink>
        </para>
    </section>

    <section>
      <title>Reporting problems</title>

      <para>If you run into trouble don't hesitate to get in touch with us:
      <itemizedlist>
          <listitem>
            <para>JIRA Issue Tracking: <ulink url="https://jira.jboss.org/jira/browse/ERRAI">https://jira.jboss.org/jira/browse/ERRAI </ulink></para>
          </listitem>

          <listitem>
              <para>
              User Forum:

            <ulink url="http://www.jboss.org/index.html?module=bb&amp;op=viewforum&amp;f=295">http://www.jboss.org/index.html?module=bb&amp;op=viewforum&amp;f=295</ulink>
              </para>
          </listitem>

          <listitem>
              <para>
              Mailing List:

            <ulink url="http://jboss.org/errai/MailingLists.html">http://jboss.org/errai/MailingLists.html</ulink>
              </para>
          </listitem>

          <listitem>
              <para>
              IRC: irc://irc.freenode.net/errai
              </para>
          </listitem>
        </itemizedlist></para>
    </section>
  </chapter>

     <!---
        =====================================================
        INSTALLATION
        =====================================================
    -->

  <chapter id="installation">
    <title>Installation</title>

    <section>
      <title>Required software</title>

      <para>Errai requires a JDK version 5 or higher and depends on Apache
      Maven to build and run the examples, and for leverging the quickstart
      utilities. <itemizedlist>
          <listitem>
              <para>
              JDK 5: <ulink url="http://java.sun.com/javase/downloads/index.jsp">http://java.sun.com/javase/downloads/index.jsp</ulink>
              </para>
          </listitem>

          <listitem>
              <para>
              Apache Maven: <ulink url="http://maven.apache.org/download.html">http://maven.apache.org/download.html</ulink>
              </para>
          </listitem>
        </itemizedlist>
        <note>
          <title>Launching maven the first time</title>

          <para>Please note, that when launching maven the first time on your
          machine, it will fetch all dependecies from a central repository.
          This may take a while, because it includes downloading large
          binaries like GWT SDK. However subsequent builds are not required to
          go through this step and will be much faster.</para>
        </note>
      </para>
    </section>

    <section id="thedistribution">
      <title>Distribution Package</title>

      <para>Unzip the Errai download (<literal>Errai-X.Y.zip</literal>) to
      some location on your hard drive. You'll see following
      subdirectories:</para>

      <itemizedlist>
        <listitem>
            <para>
          <filename>doc</filename>: User guide and javadocs 
            </para>
        </listitem>

        <listitem>
            <para>
          <filename>examples</filename>: Examples that are used in the user guide
            </para>
        </listitem>

        <listitem>
            <para>
          <filename>lib</filename>: Required libraries
            </para>
        </listitem>
      </itemizedlist>
    </section>
  </chapter>

     <!---
        =====================================================
        BUS
        =====================================================
    -->

  <chapter id="bus">
    <title>Errai Bus</title>

    <sect1 id="bus-intro">
      <title>What is Errai Bus?</title>

      <para>ErraiBus forms the backbone of the Errai framework's approach to
      application design. Most importantly, it provides a straight-forward
      approach to a complex problem space. Providing common APIs across the
      client and server, developers will have no trouble working with complex
      messaging scenarios from building instant messaging clients, stock
      tickers, to monitoring instruments. There's no more messing with RPC
      APIs, or unweildy AJAX or COMET frameworks. We've built it all in to
      one, consice messaging framework. It's single-paradigm, and it's fun to
      work with.</para>
    </sect1>

    <sect1>
      <title>Messaging</title>

      <para>This section will start off with some solid code examples and
      describe the different messaging patterns that are employed by ErraiBus.
      In later sections, we'll delve into the different percularities of the
      API, implications, and more complex cases.</para>

      <sect2>
        <title>MessageBuilder and MessageListener API</title>

        <para>The MessageBuilder is the heart of the messaging API in
        ErraiBus. It provides a fluent / builder API, that is used for
        constructing messages. All three major message patterns can be
        constructed from the MessageBuilder.
        </para>

          <para>
              Components that want to receive messages need to implement
              the MessageCallback interface.
          </para>

          <para>But before we dive into the details, let look at some use cases first.</para>
      </sect2>

      <sect2>
        <title>Receiving messages on the server side</title>

        <para>Every message has a sender and at least one receiver. A receiver
        is as it sounds--it receives the message and does something with it.
        Implementing a receiver (also referred to as a service) is as simple
        as implementing our standard MessageCallback interface, which is used
        pervasively across, both client and server code. Let's begin with
        server side component that receives messages: </para>

        <programlisting>   @Service
    public class HelloWorldService implements MessageCallback {
        public void callback(Message message) {
            System.out.println("Hello, World!");
        }
    }</programlisting>

        <para>He we declare an extremely simple service. The @Service
        annotation provides a convenient, meta-data based way of having the
        bus auto-discover and deploy the service.</para>
      </sect2>

      <sect2>
        <title>Sending messages from a client</title>

        <para>In order to send a message from a client you need to create a
        <emphasis><emphasis><filename>Message</filename></emphasis></emphasis>
        and send it through an instance of <filename>MessageBus</filename>. In
        this simple example we send it to the subject
        'HelloWorldService'.</para>

        <programlisting>    public class HelloWorld implements EntryPoint {

        // Get an instance of the MessageBus
        private MessageBus bus = ErraiBus.get();

        public void onModuleLoad() {
            Button button = new Button("Send message");

            button.addClickHandler(new ClickHandler() {

            public void onClick(ClickEvent event) {
                // Send a message to the 'HelloWorldService'.
                MessageBuilder.createMessage()
                    .toSubject("HelloWorldService")             // (1)
                    .signalling()                               // (2)
                    .noErrorHandling()                          // (3)
                    .sendNowWith(bus);                          // (4)
            });

            [...]
         }
    }</programlisting>

        <para>In the above example we build and send a message every time the
        button is clicked. Here's an explanation of what's going on as
        annotated above:</para>

        <orderedlist>
          <listitem>
            <para>We specify the subject we wish to send a message to. In this
            case, "HelloWorldService".</para>
          </listitem>

          <listitem>
            <para>We indicate that we wish to only signal the service,
            meaning, that we're not sending a qualifying command to the
            service. For information on this, read the section on
            <emphasis>Protocols</emphasis>.</para>
          </listitem>

          <listitem>
            <para>We indicate that we do not want to provide an ErrorCallback
            to deal with errors for this message.</para>
          </listitem>

          <listitem>
            <para>We transmit the message by providing an instance of the
            MessageBus</para>
          </listitem>
        </orderedlist>

        <note>
            <para>
                On the client side a reference to the bus is obtained
                through the singleton ErraiBus.get(). On the server side however
                it's slightly different. Here the <ulink url="http://code.google.com/p/google-guice/">Guice dependency injection</ulink> provides us with
                a bus reference, as we can see in the next example.
            </para>
        </note>
      </sect2>

      <sect2>
        <title>Sending messages to a client</title>

        <para>In the following example we extend our server side component to
        reply with a message when the callback method is invoked. It will
        create a message and address it to the subject 'HelloWorldClient':
        </para>

        <programlisting>    @Service
    public class HelloWorldService implements MessageCallback {

        private MessageBus bus;

        @Inject                                         
        public HelloWorldService(MessageBus bus) {
            this.bus = bus;
        }

        public void callback(CommandMessage message) {
                // Send a message to the 'HelloWorldClient'.
                MessageBuilder.createMessage()
                    .toSubject("HelloWorldClient")              // (1)
                    .signalling()                               // (2)
                    .with("text", "Hi There")                   // (3)
                    .noErrorHandling()                          // (4)
                    .sendNowWith(bus);                          // (5)
            });
        }
    }   </programlisting>

        <para>The above example shows a service which sends a message in
        response to receiving a message. Here's what's going on:</para>

        <orderedlist>
          <listitem>
            <para>We specify the subject we wish to send a message to. In this
            case, "HelloWorldClient". We are sending this message to all
            clients which are listening in on this subject. For information on
            how to communicate with a single client, see Section 2.6.</para>
          </listitem>

          <listitem>
            <para>We indicate that we wish to only signal the service, meaning
            that we're not sending a qualifying command to the service. For
            information on this, read the section on Protocols.</para>
          </listitem>

          <listitem>
            <para>We add a message part called "text" which contains the value
            "Hi there".</para>
          </listitem>

          <listitem>
            <para>We indicate that we do not want to provide an ErrorCallback
            to deal with errors for this message.</para>
          </listitem>

          <listitem>
            <para>We transmit the message by providing an instance of the
            MessageBus.</para>
          </listitem>
        </orderedlist>
      </sect2>

      <sect2>
        <title>Receiving messages on the client side</title>

        <para>If a client needs to receive messages that are "pushed" from the
        server side it needs to register a listener on a certain subject.
        <programlisting>

    public class HelloWorld implements EntryPoint {
        private MessageBus bus = ErraiBus.get();

        public void onModuleLoad() {
        [...]

        /**
        * Declare a local service to receive messages on the subject
        * "BroadcastReceiver".
        */
        bus.subscribe("BroadcastReceiver", new MessageCallback() {
            public void callback(CommandMessage message) {
                /**
                * When a message arrives, extract the "text" field and
                * do something with it
                */
                String messageText = message.get(String.class, "text");
            }
        });

        [...]
    }
               </programlisting></para>
      </sect2>

      <sect2>
        <title>Conversations</title>

        <para>Conversations are message exchanges which are between a single
        client and a service. They are a fundmentally important concept in
        ErraiBus, since by default, a message will be broadcast to all client
        services listening on a particular channel.</para>

        <para>When you create a conversation with an incoming message, you
        ensure that the message you are sending back is received by the same
        client which sent the incoming message. A simple example:</para>

        <programlisting>   @Service
    public class HelloWorldService implements MessageCallback {

        private MessageBus bus;

        @Inject
        public HelloWorldService(MessageBus bus) {
            this.bus = bus;
        }

        public void callback(CommandMessage message) {
                // Send a message to the 'HelloWorldClient' on the client that sent us the
                // the message.
                MessageBuilder.createConversation(message)
                    .toSubject("HelloWorldClient")
                    .signalling()
                    .with("text", "Hi There! We're having a conversation!")
                    .noErrorHandling()
                    .sendNowWith(bus);
            });
        }
    }</programlisting>

        <para>Note that the only difference between the example in the
        previous section (2.4) and this is the use of the
        <filename>createConversation() </filename>method with
        <filename>MessageBuilder</filename>.</para>

        <para></para>

        <sect3>
          <title>Sender Inferred Subjects</title>

          <para>It is possible for the sender to infer, to whatever
          conversational service it is calling, what subject it would like the
          reply to go to. This is accomplished by utilizing the standard
          <filename>MessageParts.ReplyTo</filename> message part. Using this
          methodology for building conversations is generally
          encouraged.</para>

          <para>Consider the following client side code:</para>

          <programlisting>MessageBuilder.createMessage()
       .toSubject("ObjectService").signalling()
       .with(MessageParts.ReplyTo, "ClientEndpoint")
       .noErrorHandling().sendNowWith(bus);</programlisting>

          <para>And the conversational code on the server (for service
          <emphasis>ObjectService</emphasis>):</para>

          <programlisting>MessageBuilder.createConversation(message)
                .subjectProvided().signalling()
                .with("Records", records)
                .noErrorHandling().sendNowWith(bus);</programlisting>

          <para>In the above examples, assuming that the latter example is
          inside a service called "ObjectService" and is referencing the
          incoming message that was send in the former example, the message
          created will automatically reference the
          <filename>ReplyTo</filename> subject that was provided by the
          sender, and send the message back to the subject desired by the
          client on the client that sent the message.</para>
        </sect3>
      </sect2>

      <sect2>
        <title>Broadcasting</title>

        <para>Broadcasting messages to all clients listening on a specific
        subject is quite simple and involves nothing more than forgoing use of
        the conversation API. For instance:</para>

        <programlisting>MessageBuilder.createMessage().
                 .toSubject("MessageListener")
                 .with("Text", "Hello, from your overlords in the cloud")
                 .noErrorHandling().sendNowWith(bus);</programlisting>

        <para>If sent from the server, all clients currently connected, who
        are listening to the subject <filename>"MessageListener"</filename>
        will receive the message. It's as simple as that.</para>
      </sect2>

      <sect2>
        <title>Client-to-Client Communication</title>

        <para>Communication from one client to another client is not directly
        possible within the bus federation, by design. This isn't to say that
        it's not possible. But one client cannot see a service within the
        federation of another client. We institute this limitation as a matter
        of basic security. But many software engineers will likely find the
        prospects of such communication appealing, so this section will
        provide some basic pointers on how to go about accomplishing
        it.</para>

        <sect3>
          <title>Relay Services</title>

          <para>The essential architectural thing you'll need to do is create
          a relay service that runs on the server. Since a service advertised
          on the server is visible to all clients and all clients are visible
          to the server, you might already see where we're going with
          this.</para>

          <para>By creating a service on the server which accepts messages
          from clients, you can create a simple protocol on-top of the bus to
          enable quasi peer-to-peer communication. (We say quasi, because it
          still needs to be routed through the server)</para>

          <para>While you can probably imagine simply creating a
          broadcast-like service which accepts a message from one client and
          broadcasts it to the rest of the world, it may be less clear how to
          go about routing from one particular client to another particualr
          client, so we'll focus on that problem.</para>

          <para><emphasis role="bold">Message Routing
          Information</emphasis></para>

          <para>Every message that is sent between a local and remote (or
          server and client) buses contain session routing information. This
          information is used by the bus to determine what outbound queue's to
          use to deliver the message to their intended recipients. It is
          possible to manually specify this information to indicate to the
          bus, where you want a specific message to go.</para>

          <para>The utility class
          <filename>org.jboss.errai.bus.server.util.ServerBusUtils</filename>
          contains a utility method for extracting the String-based SessionID
          which is used to identify the message queue associated with any
          particular client. You may use this method to extract the SessionID
          from a message so that you may use it for routing. For
          example:</para>

          <programlisting>...
public void callback(Message message) {
    String sessionId = ServerBusUtils.getSessionId(message);

    // Record this sessionId somewhere.
    ...
}
...

</programlisting>

          <para>The SessionID can then be stored in a medium, say a Map, to
          cross-reference specific users or whatever identifier you wish to
          allow one client to obtain a reference to the specific ClientId of
          another client. In which case, you can then provide the SessionID as
          a MessagePart to indicate to the bus where you want the message to
          go.</para>

          <programlisting>MessageBuilder.createMessage()
    .toSubject("ClientMessageListener")
    .signalling()
    .with(MessageParts.SessionID, sessionId)
    .with("Message", "We're relaying a message!")
    .noErrorHandling().sendNowWith(bus);
</programlisting>

          <para>By providing the SessionID part in the message, the bus will
          see this and use it for routing the message to the relevant
          queue.</para>

          <para>Now you're routing from client-to-client!</para>
        </sect3>
      </sect2>
    </sect1>

    <sect1>
      <title>Remote Procedure Calls (RPC)</title>

      <para>ErraiBus supports a high-level RPC layer to make typical
      client-server RPC communication easy on top of the bus. While it is
      possible to use ErraiBus without ever using this API, you may find it to
      be a more useful and concise approach to exposing services to the
      clients.</para>

      <sect2>
        <title>Creating callable endpoints</title>

        <para>ErraiBus provides facility to making asynchronous RPC calls
        on-top of the bus archhitecture without the need to explicitly declare
        services or any specific mapping or boilerplate code. This method of
        communicating with the server is straight-forward and utilizes the
        simple <filename>RemoteCall</filename> API.</para>

        <para>Remote procedure calls can be be performed against against
        service class which has been annoted with the
        <filename>@Service</filename> annotation and the accompanying method
        which is being called has been annotated with the
        <filename>@Endpoint</filename> annotation, and the method has public
        access.</para>

        <programlisting>@Service
public class QueryService {
   private Map&lt;String, String[]&gt; dataMap;

   public QueryService() {
      setupMap();
   }

   private void setupMap() {
      dataMap = new HashMap&lt;String, String[]&gt;();
      dataMap.put("beer", new String[]{"Heineken", "Budweiser", "Hoogaarden"});
      dataMap.put("fruit", new String[]{"Apples", "Oranges", "Grapes"});
      dataMap.put("animals", new String[]{"Monkeys", "Giraffes", "Lions"});
   }

   @Endpoint
   public String[] getQuery(String queryString) {
      return dataMap.get(queryString.toLowerCase());
   }
}</programlisting>

        <para>Notice the <filename>@Endpoint </filename>annotation on the
        <filename>getQuery()</filename> method in the above figure. In this
        example, the method simply accepts a single String parameter and
        returns an array of Strings. The method can accept and return any
        serializable types that have been exposed to the bus within the rules
        of serializability as laid out in the section on <emphasis>Object
        Serialization</emphasis>.</para>

        <para>Also note that in this example, the service class is not
        required to implement the <filename>MessageCallback</filename>
        interface and is a simple POJO class.</para>
      </sect2>

      <sect2>
        <title>Making calls</title>

        <para>Calls to RPC endpoints are made using the RemoteCall API which
        is very similar to the MessageBuilder API, with a few key differences.
        Here is some code for calling the RPC endpoint we defined in section
        3.1.</para>

        <programlisting>MessageBuilder.createCall()
           .call("QueryService")                                         // (1)
           .endpoint("getQuery", queryBox.getText())                     // (2)
           .respondTo(String[].class, new RemoteCallback&lt;String[]&gt;() {   // (3)
               public void callback(String[] resultsString) {
                   if (resultsString == null) {
                       resultsString = new String[]{"No results."};
                   }

                   /**
                    * Build an HTML unordered list based on the results.
                    */
                   StringBuffer buf = new StringBuffer("&lt;ul&gt;");
                   for (String result : resultsString) {
                       buf.append("&lt;li&gt;").append(result).append("&lt;/li&gt;");
                   }
                   results.setHTML(buf.append("&lt;/ul&gt;").toString());
               }
           })
           .noErrorHandling()
           .sendNowWith(bus);                                           // (4)</programlisting>

        <para>In this example we <emphasis role="bold"><emphasis
        role="bold">(1)</emphasis></emphasis> send a call to the
        <filename>"QueryService"</filename> class with <emphasis
        role="bold">(2)</emphasis> the endpoint
        <filename>"getQuery"</filename>, which is the name of the method which
        we annotated, along with the parameter we which to pass to the method.
        Note that you can send as many parameters as you want as the
        <filename>endpoint()</filename> method accepts varargs
        parameter.</para>

        <para>Then <emphasis role="bold">(3)</emphasis> we declare a
        <filename>RemoteCallback</filename> to handle the response back from
        the server. We declare the response type to be that of
        <filename>String[]</filename> to correlate with the return type of the
        endpoint on the server and fill in handling code for the response. In
        this case we output an HTML unordered list manually.</para>

        <para>Finally <emphasis role="bold">(4)</emphasis> we send the
        call.</para>
      </sect2>
    </sect1>

    <sect1>
      <title>Serialization</title>

      <para>Serialization on the ErraiBus supports serialization within the
      same scope and limitations as the default GWT RPC serialization rules.
      In order to expose your domain objects to the bus so they can be
      exported across the bus, you must annotate them with the
      <filename>org.jboss.errai.bus.server.annotations.ExposeEntity</filename>
      annotation. The presence of this annotation will cause Errai's GWT
      compiler extensions to generate marshall/demarshall stubs for the
      annotated objects at compile-time.</para>

      <para>For example:</para>

      <programlisting>

@ExposeEntity
public class User implements java.io.Serializable {
    private int userId;

    public int getUserId() {
        return userId;
    }

    public void setUserId(int userId) {
        this.userId = userId;
    }
 [...]
}
      </programlisting>

      <note>
          <para>
          All exposed entities must follow the <ulink url="http://en.wikipedia.org/wiki/JavaBean">java bean convention</ulink>              
        </para>
      </note>
        
    </sect1>

    <sect1 id="wiring">
      <title>Wiring server side components</title>

      <para>Currently, ErraiBus uses Google Guice to wire components. However,
      we plan on falling back on the <emphasis>JSR-330 Dependency
      Injection</emphasis> specification in the near future. When deploying
      services on the server-side, it is currently possible to obtain
      references to the <filename>MessageBus</filename>,
      <filename>RequestDispatcher</filename>, the
      <filename>ErraiServiceConfigurator</filename>, and
      <filename>ErraiService</filename> by declaring them as injection
      dependencies.</para>
    </sect1>

    <sect1>
      <title>Bus configuration</title>

      <para><emphasis>Note: The details in this section are currently subject
      to change. Please consult this section if you are working off
      pre-release versions of ErraiBus.</emphasis></para>

      <sect2>
        <title>web.xml and app server configuration</title>

        <para>Depending on what application server you are deploying on, you
        must provide an appropriate servlet implementation if you wish to use
        true, asynchronous I/O.</para>

        <para>Here's a sample web.xml file:</para>

        <programlisting>&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
		  http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
         version="2.5"&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;ErraiServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.jboss.errai.bus.server.servlet.DefaultBlockingServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;ErraiServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.erraiBus&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;context-param&gt;
        &lt;param-name&gt;errai.properties&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/errai.properties&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;context-param&gt;
        &lt;param-name&gt;login.config&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/login.config&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;context-param&gt;
        &lt;param-name&gt;users.properties&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/users.properties&lt;/param-value&gt;
    &lt;/context-param&gt;

&lt;/web-app&gt;</programlisting>
      </sect2>

      <sect2 id="bus-config">
        <title>ErraiService.properties</title>

        <para>The ErraiService.properties file contains basic configuration
        for the bus itself.</para>

        <para>Example Configuration:</para>

        <programlisting>
##
## Request dispatcher implementation (default is SimpleDispatcher)
##
#errai.dispatcher_implementation=org.jboss.errai.bus.server.SimpleDispatcher
errai.dispatcher_implementation=org.jboss.errai.bus.server.AsyncDispatcher


#
## Worker pool size.  This is the number of threads the asynchronous worker pool should provide for processing
## incoming messages. This option is only valid when using the AsyncDispatcher implementation.
##
errai.async.thread_pool_size=5

##
## Worker timeout (in seconds).  This defines the time that a single asychronous process may run, before the worker pool
## terminates it and reclaims the thread.   This option is only valid when using the AsyncDispatcher implementation.
##
errai.async.worker.timeout=5

##
## Specify the Authentication/Authorization Adapter to use
##
#errai.authentication_adapter=org.jboss.errai.persistence.server.security.HibernateAuthenticationAdapter
#errai.authentication_adapter=org.jboss.errai.bus.server.security.auth.JAASAdapter

##
## This property indicates whether or not authentication is required for all communication with the bus.  Set this
## to 'true' if all access to your application should be secure.
##
#errai.require_authentication_for_all=true



</programlisting>

        <sect3>
          <title>errai.dispatcher_implementation</title>

          <para>The <filename>errai.dispatcher_implementation</filename>
          defines, as it's name quite succinctly implies, the dispatcher
          implementation to be used by the bus. There are two implementations
          which come with Errai out of the box: the
          <filename>SimpleDispatcher</filename> and the
          <filename>AsyncDispatcher</filename>. See section on Dispatchers for
          more information about the differences between the two.</para>
        </sect3>

        <sect3>
          <title>errai.async_thread_pool_size</title>

          <para>Specifies the total number of worker threads in the worker
          pool for handling and delivering messages. Adjusting this value does
          not have an effect if you are using the SimpleDispatcher.</para>
        </sect3>

        <sect3>
          <title>errai.async_worker.timeout</title>

          <para>Specifies the total amount of a time (in seconds) a service
          has to finish processing an incoming message before the pool
          interrupts the thread and returns an error. Adjusting this value
          does not have an effect if you are using the
          SimpleDispatcher.</para>
        </sect3>

        <sect3>
          <title>errai.authentication_adapter</title>

          <para>Specifies the authentication adapter the bus should use for
          determining whether calls should be serviced based on authentication
          and security principles.</para>
        </sect3>

        <sect3>
          <title>errai.require_authentication_for_all</title>

          <para>Indicates whether or not the bus should always require the use
          of authentication for all requests inbound for the bus. If this is
          turned on, an authentication adapter must be defined, and any user
          must be authenticated before the bus will deliver any messages from
          the client to any service.</para>
        </sect3>
      </sect2>

      <sect2>
        <title>ErraiApp.properties</title>

        <para>The ErraiApp.properties is a marker file. It does not contain
        any configuration, but it is required that it be present in any module
        you wish Errai to scan for deployable extensions and services. It
        should be located as the top-level directory of any JAR or
        Directory-based module.</para>
      </sect2>
    </sect1>
  </chapter>

     <!---
        =====================================================
        QUICKSTART
        =====================================================
    -->
    <chapter id="workspaces">
        <title>Errai Workspaces</title>

        <sect1>
            <title>What is workspaces?</title>
            <para>
                ErraiWorkspaces provides a fully managed working UI enviroment for which to deploy your console and tooling.
                Put more succinctly: we provide you the places. All you need to do is put stuff there.
            </para>

            <sect2>
                <title>Basic concepts</title>
                <para>
                    It's good to start with an explanation of the basic workspace concepts and terminlogy that
                    we chose for it.
                </para>
                <para>
                    A workspace, in our term, is basically a collection of tools.
                    Each tool serves a distinct purpose and can represent anything you like.
                    The workspace manages the tools (or tool sets) and access to them.
                    This includes loading and initialization, history, preferences
                    and authorization amongst other things.
                    Usually tools rely on the message bus for inter component communication as well as
                    backend integration. But they are not tight to that. Workspaces makes no assumption
                    about the implementation of your tool, it merely provides the glue to keep everything together.
                </para>
            </sect2>

            <sect2>
                <title>Sandbox</title>
                <para>
                    Workspaces goes beyond simple API. It's not just another GWT module.
                    It was designed to get you started quickly,
                    without getting in your way. This includes the environment to build, deploy and test
                    your tools. We've decided to use maven to provide these capabilities.
                    It allows you to quickly get started (see <link linkend="quickstart">Maven archetype</link>),
                    but more importantly, maven repositories are used to share tool implementations across workspace assemblies.
                    This way you can easily combine your own and 3rd party tools as part of a custom workspace compilation.
                    <note>
                        <para>
                           The GWT SDK is already part of the sandbox bootstrap.
                           You get everything to get going within minutes: GWT, Errai and 3rd party libraries. 
                        </para>
                    </note>
                </para>
            </sect2>
        </sect1>


        <sect1 id="workspace-api">
            <title>Workspace API</title>
            <para>
                To begin with, we'll look at some examples how to declare tool sets
                and launch them in a workspace. 
            </para>
            <sect2>
                <title>Declaring and implementing tools</title>
                <para>
                    Tools are declared through the @LoadToolSet annotation.
                    This instructs the workspace to generate all the boiler plate to
                    wire your tools with the workspace. A tool needs to implement the WidgetProvider
                    interface. It's used by the workspace to instruct the tool to create it's UI widget when needed.
                    This widget will then be embedded in the workspace.
  <programlisting>
@LoadTool(name = "Users", group = "Administration")                          (1)
public class UserManagement implements WidgetProvider
{

  public void provideWidget(final ProvisioningCallback callback) {           (2)
    callback.onSuccess(new UserManagementWidget());
  }

  class UserManagementWidget extends LayoutPanel                             (3)
  {
      [...]
  }
}
  </programlisting>
                    <orderedlist>
                        <listitem>
                            <para>Toolset declaration including the name and group this tool belongs to</para>
                        </listitem>

                        <listitem>
                            <para>The WidgetProvider implementation is manadatory.</para>
                        </listitem>

                        <listitem>
                            <para>In this example our widget is LayoutPanel with unknown contents.
                            The implementation is up to you.</para>
                        </listitem>                        
                    </orderedlist>
                </para>
            </sect2>

            <sect2 id="rolebased">
                <title>Authorization and access to tools</title>
                <para>
                    Workspaces relies on a authentication scheme similiar to
                    JAAS. It ships with different authentication modules (i.e. Hibernate, JAAS)
                    that enable role based access to tools on the client side and services on the server side.
<programlisting>
@LoadTool(name = "Inventory", group = "Administration")                (1)
@RequireRoles({"admin"})                                               (2)
public class Inventory implements WidgetProvider
{

    public void provideWidget(final ProvisioningCallback callback)     (3)
    {
        [...]
    }

}

</programlisting>
                    <orderedlist>
                        <listitem>
                            <para>A tool declaration</para>
                        </listitem>

                        <listitem>
                            <para>It restricts access to the role 'admin'</para>
                        </listitem>

                        <listitem>
                            <para>Implements the default WidgetProvider interface which will only be invoked
                            when the principal is authorized to access this tool.</para>
                        </listitem>
                    </orderedlist>
                </para>
            </sect2>

            <sect2>
                <title>Common coding pattern</title>
                <para>
                    It's common to use the WidgetProvider API in a way that <ulink url="http://code.google.com/p/google-web-toolkit/wiki/CodeSplitting">GWT 2.0
                    code splitting</ulink> can kick in. This allows true lazy loading of tools upon demand,
                    including all .js and resources necessary to run your tools:
<programlisting>
@LoadTool(name = "Group Tasks", group = "Tasks")
public class OpenTasksModule implements WidgetProvider
{
    static OpenTasksView instance = null;

    public void provideWidget(final ProvisioningCallback callback)
    {
        GWT.runAsync(
            new RunAsyncCallback()
            {
              public void onFailure(Throwable err)
              {
                GWT.log("Failed to load tool", err);
              }

              public void onSuccess()
              {
                if (instance == null) {
                  instance = new OpenTasksView();  // your tool here
                }
                callback.onSuccess(instance);
              }
            }

        );
    }
}

</programlisting>

                </para>
            </sect2>
        </sect1>

        <sect1>
            <title>Core features</title>
            <para>
                The workspace itself doesn't require any attention apart from the
                common API that is decribed in the chapter <link linkend="workspace-api">"Workspace API"</link>.
                Still, in some cases you may need to go beyond the out-of-the-box functionlity.
                In this chapter we are going to explain the building blocks used in the workspace implementation
                and how they can be used to replace or extend the default workspace behaviour.
            </para>

            <sect2 id="workspace-registry">
                <title>Workspace Registry</title>
                <para>
                    The workspace registry (org.jboss.errai.workspaces.client.framework.Registry)
                    is a simple all purpose lookup for common workspace API that is available
                    to any workspace component:
<programlisting>
AuthenticationContext authenticationContext =
    Registry.get(SecurityService.class).getAuthenticationContext();    
</programlisting>
                </para>
            </sect2>
            <sect2>
                <title>Authentication and Authorization</title>
                <para>
                    The workspace itself doesn't provide an authentication component.
                    Instead it relies on the Authentication provided by errai bus.
                    When the workspace is loaded two thing happen: The workspace checks if authentication
                    is required and, after authentication if needed, loads the tool sets. 
                </para>
                <para>
                    The bus component in charge is the SecurityService (org.jboss.errai.bus.client.security.SecurityService).
                    It is available through <link linkend="workspace-registry">workspace Registry</link>.
                    For people extending the workspace functionality it offers two intersting options:
                    <itemizedlist>
                        <listitem>
                            <para>
                                Obtain access to the authentication context (username, roles, etc)
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                Deferred workspace assembly                                
                            </para>
                        </listitem>
                    </itemizedlist>
                   The later is important of you want to provide your own way of authenticating users,
                   but still use the <link linkend="rolebased">role based authorization</link> build into workspaces.

                    <note>
                        <para>
                            Don't mess with the authentication unless you now what you are doing.
                            In many cases it might be better to extend the server side authentication adapters
                            instead of overriding the client behaviour. However for the sake of completeness,
                            this mechanism should be mentioned here.
                        </para>
                    </note>
                </para>

            </sect2>

            <sect2>
                <title>LoginClient</title>
                <para>
                  The LoginClient is the counter part of the SecurityService. It is instructed
                  by the SecurityService to request the credentials upon demand. This typically happens
                  when the workspace is initialized, but might also occur later on, when a particular service requires a different role set, then the one assigned initially. We call this elevation.
                  Similiar to the operating system of your choice that demands administrator priviledges for certain
                  operations.
                </para>
                <para>
                    After the initial authentication (or lack of) the LoginClient instructs the actual workspace
                    to assemble the tool sets.
                </para>
            </sect2>

            <sect2>
                <title>History management and perma links</title>
                <para>
                    History is build into the workspace. It's wired to the main navigation and allows
                    to use the browser navigation to switch between previously selected tools.
                    In addition to that, the same mechanism can be used to perma link tools from external applications.
                    I.e. when notifying users, using an email that contains a link back to a particular tool.
                </para>
            </sect2>

            <sect2>
                <title>Preferences</title>
                <para>
                    The workspace allows you to store simple key-value pairs as preferences.
                    Like with other common API, you obtain the Preferences through the <link linkend="workspace-registry">workspace Registry</link>.
                    The default implementation uses a cookie based approach, but it's easy to replace that one with a custom
                    implementation in the module decriptor:
<programlisting>
    <![CDATA[
   <module>
    [...]
    <replace-with class="org.jboss.errai.workspaces.client.framework.CookiePreferences">
           <when-type-is class="org.jboss.errai.workspaces.client.framework.Preferences"/>
       </replace-with>
    </module>
    ]]>
</programlisting>
                </para>
            </sect2>
                        
        </sect1>

        <sect1 id="using-workspaces">
            <title>Building a workspaces application</title>
            <para>
                In this section we go through the steps necessary to create
                a workspace application. As mentioned before, workspaces is more then just another GWT library.
                It's intended to get you started quickly. This includes GWT installation,
                creating a build environment and prepapring your IDE.  
            </para>

            <sect2>
                <title>Check the prerequisites</title>
                <para>
                    You need <ulink url="http://maven.apache.org">Apache Maven</ulink> and a <ulink url="http://java.sun.com/javase/downloads/index.jsp">JDK</ulink> to get started.
                </para>
            </sect2>

            <sect2>
                <title>Setup a build environent</title>
                <para>
                    The most simple (and least error prone) way to get started
                    is using the maven archetype that we ship as part of errai.
                    Simply follow the instructions in the <link linkend="quickstart">quickstart</link>
                    section and return here when you are done.
                </para>

                <para>
                   Once you've created a project using the maven archetype, make yourself familiar with
                   the directory structure:
<programlisting>
Laika:gwt-app hbraun$ lstree
| pom.xml    
|-src
|---main
|-----java
|-------foo
|---------bar
|-----------client
|-----------server
|-war
|---WEB-INF
</programlisting>
                    It basically follows the default GWT guidelines for breaking up code between client and server.
                    Simply put tools (@LoadToolSet) into the client subpackage and services (@Service) into the server subpackages.
                    Make sure you are familiar with the <link linkend="workspace-api">Workspace API</link> before you continue.
                </para>
            </sect2>
            <sect2>
                <title>Verify the application configuration</title>
                <para>
                    Several configuration files drive a workspace build and the
                    final application. Make sure to include all of them when porting
                    the archetype example to a different GWT application:

<programlisting>
 ./src/main/java/ErraiApp.properties
 ./src/main/java/ErraiService.properties
 ./src/main/java/my/app/App.gwt.xml   
</programlisting>
                    <orderedlist>
                        <listitem>
                            <para>
                              ErraiApp.properties is a simple marker, that is required
                              for the annotation processing to discover your modules.
                              This is especially important when you declare maven dependencies
                              on tool or service implementations. Make sure that any classpath entry
                              (i.e. dependency jar) contains an ErraiApp.properties file.
                              Otherwise errai might not be able to discover your components.
                            </para>
                        </listitem>

                        <listitem>
                            <para>
                              ErraiService.properties is the primary bus configuration.
                              Details can be found in the chapter <link linkend="bus-config">bus configuration.</link>
                            </para>
                        </listitem>

                        <listitem>
                            <para>
                              App.gwt.xml is your applications <ulink url="http://code.google.com/webtoolkit/doc/latest/DevGuideOrganizingProjects.html#DevGuideModules">module descriptor</ulink>.
<programlisting>
 <![CDATA[
<module rename-to="app">
 <inherits name='com.google.gwt.user.User'/>
 <inherits name="com.google.gwt.uibinder.UiBinder"/>
 <inherits name="com.google.gwt.resources.Resources" />

 <inherits name="org.jboss.errai.common.ErraiCommon"/>
 <inherits name="org.jboss.errai.bus.ErraiBus"/>
 <inherits name="org.jboss.errai.workspaces.ErraiWorkspaces" />
 
 <entry-point class='my.app.client.HelloWorldClient'/>

</module>
]]>    
</programlisting>
                                If you are building on workspaces make sure to include it's dependencies common and bus as well.
                            </para>
                        </listitem>
                    </orderedlist>

                </para>
            </sect2>

            <sect2>
                <title>Launch the hosted mode and start developing</title>
                <para>
                    If you followed the steps above, and did build your application stub using
                    the maven archetype, then you should be launch the <ulink url="http://code.google.com/webtoolkit/doc/latest/DevGuideCompilingAndDebugging.html#DevGuideDevMode">GWT hosted mode</ulink> with the following commands:
<programlisting>
  mvn gwt:run

 (alternatively)   
  mvn gwt:debug
</programlisting>

                    <note>
                        <title>Launching maven the first time</title>

                        <para>Please note, that when launching maven the first time on your
                            machine, it will fetch all dependecies from a central repository.
                            This may take a while, because it includes downloading large
                            binaries like GWT SDK. However subsequent builds are not required to
                            go through this step and will be much faster.</para>
                    </note>
                </para>
            </sect2>
        </sect1>
    </chapter>


    <!---
        =====================================================
        QUICKSTART
        =====================================================
    -->
  <chapter id="quickstart">
    <title>Appendix A: Quickstart</title>

    <section id="quickstart-intro">
      <title>Using the maven archetype</title>

      <para>If you have taken a look at the examples that ship with the
      distribution, you realized that we use maven to build them. The way it
      is setup, the maven build has several benefits: <itemizedlist>
          <listitem>
             <para>It pulls the GWT from a central repository. No need for manual installation of the SDK</para>
          </listitem>

          <listitem>
             <para>It provides us with the proper dependencies in order to run the examples</para>
          </listitem>

          <listitem>
             <para>IDE setup is greatly simplfied, since most modern IDE's can directly import the maven structure</para>
          </listitem>
        </itemizedlist> In order to get you going quickly, we've provided a
      project archetype, that allows you to create a project skeleton similiar
      to the one we use for building the examples. It's based on the maven
      archetype plugin <footnote><para>
              http://maven.apache.org/plugins/maven-archetype-plugin/
        </para></footnote> and needs to be invoked from the command line:
      <programlisting>
  mvn archetype:generate \
        -DarchetypeGroupId=org.jboss.errai \
        -DarchetypeArtifactId=sandbox-archetype \
        -DarchetypeVersion=1.0.0 \
        -DarchetypeRepository=http://repository.jboss.com/maven2
            </programlisting> When invoking the archetype build it ask you
      about the maven groupId, artifactId and package name your GWT
      application should use: <programlisting>
    Define value for groupId: : <emphasis>foo.bar</emphasis>
    Define value for artifactId: : <emphasis>gwt-app</emphasis>
    Define value for version:  1.0-SNAPSHOT: :
    Define value for package:  foo.bar: : <emphasis>foo.bar.ui</emphasis>
    Confirm properties configuration:
    groupId: foo.bar
    artifactId: gwt-app
    version: 1.0-SNAPSHOT
    package: foo.bar.ui
    Y: : <emphasis>Y</emphasis>
            </programlisting> What will be created for you, is a maven build
      structure, including references to the GWT SDK and the Errai
      dependencies necessary to launch a simple application: <programlisting>
    Laika:test hbraun$ cd gwt-app/
    Laika:gwt-app hbraun$ lstree
    |-src
    |---main
    |-----java
    |-------foo
    |---------bar
    |-----------client
    |-----------server
    |-war
    |---WEB-INF
            </programlisting> In order launch the GWT hosted mode, change into
      the project directory and type: <programlisting>
    mvn gwt:run
            </programlisting> The default project includes both a HelloWorld
      client (GWT), and a HelloWorld service.</para>
    </section>
  </chapter>
</book>
